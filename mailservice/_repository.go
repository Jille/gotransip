package mailservice

import (
	_context "context"
	"github.com/transip/gotransip/v6"
	"github.com/transip/gotransip/v6/inlineobjects"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// MailServiceRepository MailServiceRepository service
type MailServiceRepository gotransip.Service

// AddMailServiceDNSEntriesToDomainsOpts Optional parameters for the method 'AddMailServiceDNSEntriesToDomains'
type AddMailServiceDNSEntriesToDomainsOpts struct {
	InlineObject28 optional.Interface
}

/*
AddMailServiceDNSEntriesToDomains Add mail service DNS entries to domains
In order to reduce spam score, several DNS records should be added.  These records have to match the details generated by the mail platform.  In case the DNS records don’t match, the Transip relay will not accept mail from your VPS.  These new records (outlined below) will not overwrite any DNS records.  Record type | Name                 | TTL       | DNS type | Value  -----------: | -------------------- | --------- | -------- | -----------------------------------------------------------------  SPF          | @                    | 5 minutes | TXT      | v&#x3D;spf1 include:_spf.transip.email ~all  DKIM         | transip-A._domainkey | 5 minutes | CNAME    | _dkim-A.transip.email.  DKIM         | transip-B._domainkey | 5 minutes | CNAME    | _dkim-B.transip.email.  DKIM         | transip-C._domainkey | 5 minutes | CNAME    | _dkim-C.transip.email.  AUTH         | x-transip-mail-auth  | 5 minutes | TXT      | 30ac13d5d73d181fda11a60f779de4fb1be42908b49fb06e46d53d2d03b5721a
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AddMailServiceDNSEntriesToDomainsOpts - Optional Parameters:
 * @param "InlineObject28" (optional.Interface of InlineObject28) -
*/
func (a *MailServiceRepository) AddMailServiceDNSEntriesToDomains(localVarOptionals *AddMailServiceDNSEntriesToDomainsOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/mail-service"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InlineObject28.IsSet() {
		localVarOptionalInlineObject28, localVarOptionalInlineObject28ok := localVarOptionals.InlineObject28.Value().(inlineobjects.InlineObject28)
		if !localVarOptionalInlineObject28ok {
			return nil, reportError("inlineObject28 should be InlineObject28")
		}
		localVarPostBody = &localVarOptionalInlineObject28
	}

	r, err := a.client.PrepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := gotransip.GenericError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetMailServiceInformation Get mail service information
You’re able to gather detailed information regarding mail service usage and credentials using this API call.  Aside from the credentials (username and password) returned objects also include current usage and quota.  Usage means the amount of emails sent using the credentials and the quota is the amount of emails allowed to be sent daily.  **Usage** will always be lower than **quota**. The quota is determined by the amount of VPSes in your account. Every VPS adds 1000 mails to your daily quota (with a maximum of 10000).  E.g.: when you own 5 VPSs, the quota on each VPS is 5000.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return InlineResponse20033
*/
func (a *MailServiceRepository) GetMailServiceInformation(ctx _context.Context) (inlineobjects.InlineResponse20033, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  inlineobjects.InlineResponse20033
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/mail-service"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.PrepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := gotransip.GenericError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v inlineobjects.InlineResponse20033
			err = a.client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := gotransip.GenericError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
RegenerateMailServicePassword Regenerate mail service password
The credentials needed to authorize with our SMTP relay servers consist of a username and password.  In case the password can’t be accessed or should be reset, you can use this API call in order to regenerate it.  As a TransIP account can only have one mail service account, the request does not need to contain a body.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (a *MailServiceRepository) RegenerateMailServicePassword(ctx _context.Context) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/mail-service"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.PrepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := gotransip.GenericError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
